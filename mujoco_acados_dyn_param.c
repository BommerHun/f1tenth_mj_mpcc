#ifdef __cplusplus
extern "C" {
#endif

#include "acados/utils/external_function_generic.h"
#include "acados/utils/math.h"
#include "blasfeo_d_blas.h"
#include "blasfeo_d_aux.h"
#include "blasfeo_d_aux_ext_dep.h"
#include <mujoco/mujoco.h>


static mjModel* m = NULL;
static mjData* d = NULL;

// the following 4 lines are generated by the higher level Python code
static char xml_path[200] = "xml_models/control_scene.xml";
static double timestep = 0.05;
static bool first_call = true;

int disc_dyn_fun_jac(void **in, void **out, void *params)
{
    // Check if mujoco model is already loaded, load if not
    char error[1000] = "Could not load mujoco model";
    if (!m || !d) {
        m = mj_loadXML(xml_path, 0, error, 1000);
        if (!m) {
            mju_error("Load model error: %s", error);
        }
        m->opt.timestep = timestep;
        // make data
        d = mj_makeData(m);
    }

    int nu = m->nu;
    int nq = m->nq;
    int nv = m->nv;
    int nx = 2 * nv;
    int np = 1;
    double qpos0[nq];
    for (int i = 0; i < nq; i++) {
        if (i == 3) qpos0[i] = 1.0; else qpos0[i] = 0.0;
    }

    // extract inputs
    // 0: [x], size: nx, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *x_args = in[0];
    struct blasfeo_dvec *x = x_args->x;
    int xi = x_args->xi; // offset in vector
    // 1: [u], size: nu, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *u_args = in[1];
    struct blasfeo_dvec *u = u_args->x;
    int ui = u_args->xi; // offset in vector

    double x_cur[nx];
    for (int i = 0; i < nx; i++) {
        x_cur[i] = BLASFEO_DVECEL(x, i+xi);
        // if (first_call) {
        //     printf("x[%d] = %f\n", i, x_cur[i]);
        // }
    }
    
    double u_cur[nu];
    for (int i = 0; i < nu; i++) {
        u_cur[i] = BLASFEO_DVECEL(u, i+ui);
    }

    const double* p = (double*)params;
    m->body_mass[8] = p[0];
    
    double qpos_actual[nq];
    for (int i = 0; i < nq; i++) {
        qpos_actual[i] = qpos0[i];
    }

    double qpos_err[nv];
    for (int i=0; i < nv; i++) {
        qpos_err[i] = x_cur[i];
    }
    mj_integratePos(m, qpos_actual, qpos_err, 1);

    for (int i=0; i < nq; i++) {
        d->qpos[i] = qpos_actual[i];
    }

    for (int i=0; i < nv; i++) {
        d->qvel[i] = x_cur[i+nv];
    }

    for (int i=0; i < nu; i++) {
        d->ctrl[i] = u_cur[i];
    }

    // compute_airflow(m, d);  // TODO: this function should compute the force and torque on the payload and set d->xfrc_applied accordingly
    mj_step(m, d);
    mj_differentiatePos(m, qpos_err, 1, qpos0, d->qpos);

    // extract outputs
    // 0: [fun], size: nx1, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *f_args = out[0];
    struct blasfeo_dvec *fun = f_args->x;
    // 1: [jac_u'; jac_x'], size: (nu+nx)*nx1, type: BLASFEO_DMAT_ARGS
    struct blasfeo_dmat_args *j_args = out[1];
    struct blasfeo_dmat *jac = j_args->A;
    int f_off = f_args->xi; // offset in vector


    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, qpos_err[i], fun, f_off+i);
        // if (first_call) {
        //     printf("f[%d] = %f\n", i, qpos_err[i]);
        // }
    }
    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, d->qvel[i], fun, f_off+i+nv);
        // if (first_call) {
        //     printf("f[%d] = %f\n", i+nv, d->qvel[i]);
        // }
    }

    mjtNum A[nx*nx];
    mjtNum B[nx*nu];

    for (int i=0; i < nv; i++) {
        qpos_err[i] = x_cur[i];
        // printf("x[%d] = %.3f\n", i, x_cur[i]);
    }
    for (int i=0; i < nq; i++) {
        qpos_actual[i] = qpos0[i];
    }    

    mj_integratePos(m, qpos_actual, qpos_err, 1);
    for (int i=0; i < nq; i++) {
        d->qpos[i] = qpos_actual[i];
        // printf("qpos[%d] = %.3f\n", i, d->qpos[i]);
    }    
    for (int i=0; i < nv; i++) {
        d->qvel[i] = x_cur[i+nv];
        // printf("x[%d] = %.3f\n", i+10, x_cur[i+10]);
        // printf("qvel[%d] = %.3f\n", i, d->qvel[i]);
        d->qacc[i] = 0;
    }

    for (int i=0; i < nu; i++) {
        d->ctrl[i] = u_cur[i];
        // printf("u[%d] = %.3f\n", i, u_cur[i]);
        // printf("ctrl[%d] = %.3f\n", i, d->ctrl[i]);
    }

    mjd_transitionFD(m, d, 1e-6, true, A, B, NULL, NULL);

    double *A_blas;
    d_zeros(&A_blas, nx, nx);
    double *B_blas;
    d_zeros(&B_blas, nx, nu);

    for (int i = 0; i < nx; i++) {
        for (int j = 0; j < nx; j++) {
            // if (first_call) {
            //     printf("A[%d, %d] = %f\n", i, j, A[j + i * nx]);
            // }
            A_blas[i + j * nx] = A[j + i * nx]; // from row-major to column-major
            if (j < nu) {
                B_blas[i + j * nx] = B[j + i * nu]; // from row-major to column-major
            }
        }
    }
    first_call = false;    

    
    blasfeo_pack_tran_dmat(nx, nu, B_blas, nx, jac, 0, 0);
    blasfeo_pack_tran_dmat(nx, nx, A_blas, nx, jac, nu, 0);

    return 0;
}


int disc_dyn_fun(void **in, void **out, void *params)
{
    // Check if mujoco model is already loaded, load if not
    char error[1000] = "Could not load mujoco model";
    if (!m || !d) {
        m = mj_loadXML(xml_path, 0, error, 1000);
        if (!m) {
            mju_error("Load model error: %s", error);
        }
        m->opt.timestep = timestep;
        // make data
        d = mj_makeData(m);
    }

    int nu = m->nu;
    int nq = m->nq;
    int nv = m->nv;
    int nx = 2 * nv;
    int np = 1;
    double qpos0[nq];
    for (int i = 0; i < nq; i++) {
        if (i == 3) qpos0[i] = 1.0; else qpos0[i] = 0.0;
    }

    // extract inputs
    // 0: [x], size: nx, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *x_args = in[0];
    struct blasfeo_dvec *x = x_args->x;
    int xi = x_args->xi; // offset in vector
    // 1: [u], size: nu, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *u_args = in[1];
    struct blasfeo_dvec *u = u_args->x;
    int ui = u_args->xi; // offset in vector

    double x_cur[nx];
    for (int i = 0; i < nx; i++) {
        x_cur[i] = BLASFEO_DVECEL(x, i+xi);
        // if (first_call) {
        //     printf("x[%d] = %f\n", i, x_cur[i]);
        // }
    }
    
    double u_cur[nu];
    for (int i = 0; i < nu; i++) {
        u_cur[i] = BLASFEO_DVECEL(u, i+ui);
    }

    const double* p = (double*)params;
    m->body_mass[8] = p[0];

    double qpos_actual[nq];
    for (int i = 0; i < nq; i++) {
        qpos_actual[i] = qpos0[i];
    }

    double qpos_err[nv];
    for (int i=0; i < nv; i++) {
        qpos_err[i] = x_cur[i];
    }
    mj_integratePos(m, qpos_actual, qpos_err, 1);

    for (int i=0; i < nq; i++) {
        d->qpos[i] = qpos_actual[i];
    }

    for (int i=0; i < nv; i++) {
        d->qvel[i] = x_cur[i+nv];
    }

    for (int i=0; i < nu; i++) {
        d->ctrl[i] = u_cur[i];
    }

    // compute_airflow(m, d);  // TODO: this function should compute the force and torque on the payload and set d->xfrc_applied accordingly
    mj_step(m, d);
    mj_differentiatePos(m, qpos_err, 1, qpos0, d->qpos);

    // extract outputs
    // 0: [fun], size: nx1, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *f_args = out[0];
    struct blasfeo_dvec *fun = f_args->x;
    int f_off = f_args->xi; // offset in vector


    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, qpos_err[i], fun, f_off+i);
    }
    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, d->qvel[i], fun, f_off+i+nv);
    }

    return 0;
}


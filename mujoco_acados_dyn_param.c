#ifdef __cplusplus
extern "C" {
#endif

#include "acados/utils/external_function_generic.h"
#include "acados/utils/math.h"
#include "blasfeo_d_blas.h"
#include "blasfeo_d_aux.h"
#include "blasfeo_d_aux_ext_dep.h"
#include <mujoco/mujoco.h>


static mjModel* m = NULL;
static mjData* d = NULL;

// the following 4 lines are generated by the higher level Python code
static char xml_path[200] = "xml_models/control_scene.xml";
static float timestep = 0.01;
static int substep = 5;

int disc_dyn_fun_jac(void **in, void **out, void *params)
{
    // Check if mujoco model is already loaded, load if not
    char error[1000] = "Could not load mujoco model";
    if (!m || !d) {
        m = mj_loadXML(xml_path, 0, error, 1000);
        if (!m) {
            mju_error("Load model error: %s", error);
        }
        m->opt.timestep = timestep;
        // make data
        d = mj_makeData(m);
    }

    int nu = m->nu;
    int nq = m->nq;
    int nv = m->nv;
    int nx = 2 * nv;
    double qpos0[nq];
    for (int i = 0; i < nq; i++) {
        qpos0[i] = 0;
    }

    // extract inputs
    // 0: [x], size: nx, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *x_args = in[0];
    struct blasfeo_dvec *x = x_args->x;
    int xi = x_args->xi; // offset in vector
    // 1: [u], size: nu, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *u_args = in[1];
    struct blasfeo_dvec *u = u_args->x;
    int ui = u_args->xi; // offset in vector

    double x_cur[nx];
    for (int i = 0; i < nx; i++) {
        x_cur[i] = BLASFEO_DVECEL(x, i+xi);
        // if (first_call) {
        //     printf("x[%d] = %f\n", i, x_cur[i]);
        // }
    }
    
    double u_cur[nu];
    for (int i = 0; i < nu; i++) {
        u_cur[i] = BLASFEO_DVECEL(u, i+ui);
    }

    double qpos_err[nv];
    for (int i=0; i < nv; i++) {
         d->qpos[i] = x_cur[i];
    }
    for (int i=0; i < nv; i++) {
        d->qvel[i] = x_cur[i+nv];
        d->qacc[i] = 0;
    }

    for (int i=0; i < nu; i++) {
        d->ctrl[i] = u_cur[i];
    }

    // compute_airflow(m, d);  // TODO: this function should compute the force and torque on the payload and set d->xfrc_applied accordingly
    for (int i = 0; i < substep; i++)
    {
        mj_step(m, d);
    }
    
    mj_differentiatePos(m, qpos_err, 1, qpos0, d->qpos);

    // extract outputs
    // 0: [fun], size: nx1, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *f_args = out[0];
    struct blasfeo_dvec *fun = f_args->x;
    // 1: [jac_u'; jac_x'], size: (nu+nx)*nx1, type: BLASFEO_DMAT_ARGS
    struct blasfeo_dmat_args *j_args = out[1];
    struct blasfeo_dmat *jac = j_args->A;
    int f_off = f_args->xi; // offset in vector


    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, qpos_err[i], fun, f_off+i);
        // if (first_call) {
        //     printf("f[%d] = %f\n", i, qpos_err[i]);
        // }
    }
    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, d->qvel[i], fun, f_off+i+nv);
        // if (first_call) {
        //     printf("f[%d] = %f\n", i+nv, d->qvel[i]);
        // }
    }

    mjtNum A[nx*nx];
    mjtNum A_hat[nx*nx];
    mjtNum B[nx*nu];
    mjtNum B_hat[nx*nu];

    //mj_integratePos(m, qpos_actual, qpos_err, 1);
    for (int i=0; i < nq; i++) {
        d->qpos[i] =x_cur[i];
        // printf("qpos[%d] = %.3f\n", i, d->qpos[i]);
    }    
    for (int i=0; i < nv; i++) {
        d->qvel[i] = x_cur[i+nv];
        // printf("x[%d] = %.3f\n", i+10, x_cur[i+10]);
        // printf("qvel[%d] = %.3f\n", i, d->qvel[i]);
        d->qacc[i] = 0;
    }

    for (int i=0; i < nu; i++) {
        d->ctrl[i] = u_cur[i];
        // printf("u[%d] = %.3f\n", i, u_cur[i]);
        // printf("ctrl[%d] = %.3f\n", i, d->ctrl[i]);
    }

    
    for (int i = 0; i < nx; i++)
    {
        for (int j  = 0; j < nx; j++)
        {
            A_hat[j+i*nx] = 0;
            if (j == i)  A_hat[j+i*nx] = 1; 

            if(j < nu) B_hat[j + i *nu] = 0;
        }
        
    }
 
    
    float temp = 0;
    for (int step = 0; step < substep; step++)
    {
        mjd_transitionFD(m, d, 1e-6, false, A, B, NULL, NULL);
        mj_step(m,d);    


        for (int row = 0; row < nx; row++)
        {
            for (int col = 0; col < nx; col++)
            {
                temp = 0;
                for (int i = 0; i < nx; i++)
                {
                    // A_hat[row,col] = A[row,:] * A_hat[:,col] Iterate throuh the row of A and the column of A_hat
                    //[row, col] = row*nx + col  
                    temp += A[i + nx*row ]*A_hat[col+nx*i];  
                }
                A_hat[col+ row*nx] = temp;
            }
        }
        for (int row = 0; row < nx; row++)
        {
            for (int col = 0; col < nu; col++)
            {
                temp = 0;
                for (int i = 0; i < nx; i++)
                {
                    temp += A[i + nx*row ]*B_hat[col+nu*i];  
                }
                B_hat[col+ row*nu] = B[col+ row*nu] + temp;
            }
        }
        
    }
   
    double *A_blas;
    d_zeros(&A_blas, nx, nx);
    double *B_blas;
    d_zeros(&B_blas, nx, nu);

    for (int i = 0; i < nx; i++) {
        for (int j = 0; j < nx; j++) {
            // if (first_call) {
            //     printf("A[%d, %d] = %f\n", i, j, A[j + i * nx]);
            // }
            A_blas[i + j * nx] = A_hat[j + i * nx]; // from row-major to column-major
            if (j < nu) {
                B_blas[i + j * nx] = B_hat[j + i * nu]; // from row-major to column-major
            }
        }
    }

    
    blasfeo_pack_tran_dmat(nx, nu, B_blas, nx, jac, 0, 0);
    blasfeo_pack_tran_dmat(nx, nx, A_blas, nx, jac, nu, 0);

    return 0;
}


int disc_dyn_fun(void **in, void **out, void *params)
{

    // Check if mujoco model is already loaded, load if not
    char error[1000] = "Could not load mujoco model";
    if (!m || !d) {
        m = mj_loadXML(xml_path, 0, error, 1000);
        if (!m) {
            mju_error("Load model error: %s", error);
        }
        m->opt.timestep = timestep;
        // make data
        d = mj_makeData(m);
    }

    int nu = m->nu;
    int nq = m->nq;
    int nv = m->nv;
    int nx = 2 * nv;
    double qpos0[nq];
    for (int i = 0; i < nq; i++) {
        qpos0[i] = 0.0;
    }

    // extract inputs
    // 0: [x], size: nx, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *x_args = in[0];
    struct blasfeo_dvec *x = x_args->x;
    int xi = x_args->xi; // offset in vector
    // 1: [u], size: nu, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *u_args = in[1];
    struct blasfeo_dvec *u = u_args->x;
    int ui = u_args->xi; // offset in vector

    double x_cur[nx];
    for (int i = 0; i < nx; i++) {
        x_cur[i] = BLASFEO_DVECEL(x, i+xi);
    }
    double u_cur[nu];
    for (int i = 0; i < nu; i++) {
        u_cur[i] = BLASFEO_DVECEL(u, i+ui);
    }

    double qpos_actual[nq];
    for (int i = 0; i < nq; i++) {
        qpos_actual[i] = qpos0[i];
    }

    double qpos_err[nv];
    for (int i=0; i < nv; i++) {
        qpos_err[i] = x_cur[i];
    }
    mj_integratePos(m, qpos_actual, qpos_err, 1);

    for (int i=0; i < nq; i++) {
        d->qpos[i] = qpos_actual[i];
    }

    for (int i=0; i < nv; i++) {
        d->qvel[i] = x_cur[i+nv];
    }

    for (int i=0; i < nu; i++) {
        d->ctrl[i] = u_cur[i];
    }

    // compute_airflow(m, d);  // TODO: this function should compute the force and torque on the payload and set d->xfrc_applied accordingly
    for (int i = 0; i < substep; i++)
    {
        mj_step(m, d);
    }
    
    mj_differentiatePos(m, qpos_err, 1, qpos0, d->qpos);

    // extract outputs
    // 0: [fun], size: nx1, type: BLASFEO_DVEC_ARGS
    struct blasfeo_dvec_args *f_args = out[0];
    struct blasfeo_dvec *fun = f_args->x;
    int f_off = f_args->xi; // offset in vector


    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, qpos_err[i], fun, f_off+i);
    }
    for (int i = 0; i < nv; i++) {
        blasfeo_dvecse(1, d->qvel[i], fun, f_off+i+nv);
    }
    return 0;
}

